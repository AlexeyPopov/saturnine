{"name":"Saturnine","tagline":"Asynchronous server application framework for Clojure, based on JBoss Netty","body":"# Saturnine #\r\nSimple Asynchronous Network Application Library\r\n\r\n### Overview ###\r\n\r\nSaturnine is a Clojure library designed to facilitate rapid development of \r\nasynchronous network applications.  It is built on top of JBoss Netty, and \r\ninherits a number of features from this framework, but is designed with \r\nsimplicity in mind:\r\n\r\n- Sane defaults preferred over explicit configuration.\r\n\r\n- Common functionality built-in, including Handlers for Bytes, Strings,\r\n  (simple, tagsoup style) streaming XML, JSON, HTTP, XMPP and Clojure forms\r\n\r\n- Event driven design with easy session state management.  Applications can\r\n  be trivially run in blocking (\"thread-per-connection\") or nonblocking modes,\r\n  without modifying your application code.\r\n\r\n- SSL/TLS support (with starttls), also supports nonblocking operation.\r\n\r\nA full rundown of Saturnine's functionality can be found in the [API Documentation](http://texodus.github.com/saturnine)\r\n\r\n### Installation ###\r\n\r\nYou'll need Git, Leiningen, Java, a computer of some sort, and a source of\r\nelectricity.  Install Saturnine with:\r\n\r\n     git clone http://github.com/texodus/saturnine.git\r\n     cd saturnine\r\n     lein install\r\n\r\n... or add it to your leiningen `project.clj` ...\r\n\r\n     :dependencies [[saturnine \"0.3\"]]\r\n\r\n... or your maven pom.xml ...\r\n\r\n     <repositories>\r\n       <repository>\r\n         <id>clojars.org</id>\r\n         <url>http://clojars.org/repo</url>\r\n       </repository>\r\n     </repositories>\r\n\r\n     <dependencies>\r\n       <dependency>\r\n         <groupId>saturnine</groupId>\r\n         <artifactId>saturnine</artifactId>\r\n         <version>0.3</version>\r\n       </dependency>\r\n     </dependencies>\r\n\r\n... and add (:use 'saturnine.core) to your namespace declaration anywhere you want to\r\nuse Saturnine.\r\n\r\n### Tutorial ###\r\n\r\nSaturnine is an asynchronous framework, which means simply that all operations \r\nreturn nil immediately when invoked, and the result of an operation is passed\r\nto a supplied callback function whenever the operation is completed.  In this way, \r\nyou can design applications that continue to process, even after initiating costly\r\nIO operations.  And that's A Good Thing (c).\r\n\r\nSaturnine applications (servers ant clients) are composed of a list of sequential\r\nHandlers.  Each handler, in turn, is simply a clojure defrecord which implements \r\nthe Handler protocol.  The Handler defrecord itself represents the intermediate \r\nstate of the processed stream - when new data is received from a connection, saturnine \r\nwill call the relevent function from the Handler protocol on the first handler in the \r\nlist, which in turn calls the next handler and returns a new instance of itself that \r\nrepresents the new state of the connection, and so on.  \r\n\r\nData received from a conenction proceeds calls the first handler's upstream implementation\r\n- this handler is responsible for calling (send-up ...) to pass data to the next \r\nhandler in the list (though if this function is not implemented for a Handler, the \r\ndefault implementation will simply call send-up on the unprocessed data it received).  \r\nWhen data is written to a connection, the last handler's downstream function is called, \r\nand utilizing (send-down ...) within this handler will pass processed data to the previous\r\nhandler in the list, until it eventually propogates to the wire.\r\n\r\nSaturnine provides a number of simple Handlers by default, which are represented\r\nin the handler lsit by keys.  For example, here is a simple REPL server implemented\r\nwith only the built-in handlers:\r\n\r\n    (use 'saturnine.core)\r\n\r\n    (start-server 1234 :nonblocking :string [:print \"repl\"] :clj :echo)\r\n\r\nThis starts a nonblocking server listening on port 1234.  Once a connection is opened to\r\nthis server, incoming data is processed in the following manner:\r\n\r\n\r\n    |--> :nonblocking --> :string --> :print --> :clj --|\r\n    |                                                   v\r\n \r\n    network                                             :echo\r\n\r\n    ^                                                   |\r\n    |--  :nonblocking <-- :string <-- :print <-- :clj <--\r\n\r\n\r\n1. :string - Incoming data is converting to string data and flushed to the next \r\n   handler when a newline is encountered.\r\n\r\n2. :print - Incoming strings are logged via clojure.contrib.logging, then \r\n   flushed to the next handler.  Log lines qualified by \"repl\"\r\n\r\n3. :clj - Incoming strings are processed by the Clojure's read-string  and \r\n   eval'd, then the resulting forms are flushed to the next handler\r\n\r\n4. :echo - echo's every incoming Clojure form, back down the stack in reverse.\r\n\r\n5. :clj - the now-outbound Clojure form is flushed as a string with print-str\r\n\r\n6. :print - outbound strings are logged via clojure.contrib.logging, then \r\n   flushed\r\n\r\n7. :string - converts incoming Strings back into Bytes to send to the Connection\r\n\r\n\r\nEventually, you'll want to write your own handlers to process data - Saturnine provides\r\nthe defhandler macro for this purpose.  Think of defhandler as a souped-up defrecord, \r\nspecifically for writing Handlers - functions from the Handler protocl that are not provided\r\nas arguments are replaced with default implementations that should do abotu what you'd\r\nexpect.  For example, here's an application with a custom handler which only\r\nresponds to \"upstream\" messages, usign the default implementations for other event\r\ntypes:\r\n\r\n    (use 'saturnine.core 'saturnine.handler)\r\n\r\n    (defhandler Sum [sum]\r\n      (upstream [this msg] (let [new-sum (+ sum msg)]\r\n                             (send-down (str \"Sum is \" new-sum \"\\r\\n\"))\r\n                             (assoc this :sum new-sum))))\r\n\r\n    (start-server 1234 :blocking :string :clj (new Sum 0))\r\n\r\nBreaking this down piece by piece, Sum is a clojure datatype with a single property, :sum,\r\nand implements a single function, upstream.  By declaring sum-server to use the handler\r\n(Sum 0), we are telling Saturnine to assign new Connections this value.  When\r\nan upstream message is passed upstream from :clj, the upstream function on Sum is\r\ncalled;  this function dispatches a new downstream message with the send-down \r\nfunction, then returns a new Sum, which becomes the new state of the connection,\r\nand will be called on all future messages from this connection that are flushed\r\nfrom :clj.\r\n\r\nHere's an entire telnet chat server, which uses a Clojure Ref as it's state, allowing\r\nindepedent connections to communicate with eachother simply and thread-safely:\r\n\r\n    (use 'saturnine.core 'saturnine.handler)\r\n\r\n    (defn- write-all \r\n      [users msg]\r\n      (doseq [user (vals (dissoc users (get-ip)))]\r\n        (write user (str (get-ip) \" : \" msg))))\r\n\r\n    (defhandler Chat [users]\r\n      (connect    [_] (do (dosync (alter users assoc (get-ip) (get-connection)))\r\n                          (write-all @users \"User connected!\\r\\n\")))\r\n      (disconnect [_] (do (dosync (alter users dissoc (get-ip)))\r\n                          (write-all @users \"User disconnected!\\r\\n\")))\r\n      (upstream   [_ msg] (do (write-all @users msg))))\r\n   \r\n    (start-server 3333 :string [:print \"chat\"] (new Chat (ref {})))\r\n\r\nFor further examples, please see the [API Documentation](http://texodus.github.com/saturnine) and \r\n['saturnine.examples](http://github.com/texodus/saturnine/tree/master/src/saturnine/examples.clj) namespace.\r\n\r\n\r\n\r\n\r\n\r\n### Planned Features (global backlog) ###\r\n\r\n- UDP support\r\n- Filesystem support\r\n- Sequential flow control combinators for simple \"conversational\" control flows \r\n  in a single handler. (maybe a special sequential handler?)\r\n- XMPP enchancement, maybe some bosh?\r\n- Comet-made-easy, websockets-made-easy\r\n- Take the java out of SSL\r\n- :pre checks for state type verification\r\n- Optimization \r\n    - Implement stateless variation on handlers\r\n    - Replace SimpleChannelHandler with reified ChannelHandler\r\n    - Add support for zero-copy ChannelBuffer manipulation (including file serving)\r\n- Additional Handler optional message endpoints - bind, open, etc.\r\n- Add callbacks to send-up/send-down that are actually useful\r\n- Better HTTP support in the form of a ring adapter.\r\n- Open to suggestions ....\r\n\r\n\r\n\r\n    ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}